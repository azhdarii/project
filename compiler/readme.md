
 
`lexer.l` file is an input file for the `Lex` tool, which is used to generate a **Lexical Analyzer** (lexer). 
The lexical analyzer is the first stage in the compilation process,
and its job is to read the input text and convert it into a series of **tokens**.
Each token is a meaningful unit of the input text, such as numbers, operators, identifiers, etc.

### Explanation of the Different Sections of    `lex` File:

---

#### **Section 1: Definitions and Settings**
```c
%{
#include <stdio.h>
#include <stdlib.h>
#include "parser.tab.h" 

void reverse_string(char* str);
%}
```
- This section contains C code that is included at the beginning of the lexer file.
-  This code typically includes libraries and functions used during lexical analysis.
  - The libraries `stdio.h` and `stdlib.h` are used for input/output operations and memory management.
  - The file `parser.tab.h` is likely generated by the `Bison` tool and contains token definitions and other information needed for the syntax analyzer.
  - The `reverse_string` function is defined to reverse strings.

---

#### **Section 2: Pattern Definitions**
```lex
digit [0-9]
number {digit}+ 
letter [A-Za-z]
id {letter}({letter}|{digit})*
ws [ \t\n]+
```
- In this section, various patterns are defined to identify tokens.
  - `digit`: A single digit (0â€“9).
  - `number`: One or more digits (an integer).
  - `letter`: A single letter (uppercase or lowercase).
  - `id`: An identifier that starts with a letter and can include letters and digits.
  - `ws`: Whitespace characters (space, tab, or newline).

---

#### **Section 3: Lexical Analysis Rules**
```lex
%%
{id} { 
    yylval.id=strdup(yytext);
    return ID; 
}

{number} { 
    int num = atoi(yytext);
    if (num % 10 == 0) {
        yylval.expr_data.value = num;
        yylval.expr_data.code = strdup(yytext);
    } else {
        int reversed = 0, original = num;
        while (original != 0) {
            reversed = reversed * 10 + original % 10;
            original /= 10;
        }
        yylval.expr_data.value = reversed;
        yylval.expr_data.code = malloc(strlen(yytext) + 1); 
        if (yylval.expr_data.code == NULL) {
            fprintf(stderr, "Memory allocation failed\n");
            exit(1);
        }
        strcpy(yylval.expr_data.code, yytext);
        reverse_string(yylval.expr_data.code);
    }
    return NUMBER;
}

"=" { return '='; }
"+" { return '+'; }
"-" { return '-'; }
"*" { return '*'; }
"/" { return '/'; }
"(" { return '('; }
")" { return ')'; }
";" { return ';'; }
{ws} { /* Ignore whitespace */ }
. { printf("Unexpected character: %s\n", yytext); }
%%
```
- This section contains the lexical analysis rules. Each rule consists of a pattern and an action. When the pattern matches the input text, the corresponding action is executed.
  - `{id}`: If an identifier is found, it is stored in `yylval.id`, and the `ID` token is returned.
  - `{number}`: If a number is found, it checks whether the number is a multiple of 10. If it is, the number is used as is. Otherwise, the number is reversed. The value and corresponding code are stored in `yylval.expr_data`, and the `NUMBER` token is returned.
  - Operators and parentheses: Each of these characters is returned as the corresponding token.
  - `{ws}`: Whitespace characters are ignored.
  - `.`: Any unexpected character is printed.

---

#### **Section 4: Helper Functions**
```c
void reverse_string(char* str) {
    int len = strlen(str);
    for (int i = 0; i < len / 2; i++) {
        char temp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = temp;
    }
}
```
- This function is used to reverse a string. Here, it is used to reverse numbers that are not multiples of 10.

---

### **Summary:**
   `lex` file creates a lexical analyzer that reads the input text and converts it into meaningful tokens.
   These tokens include numbers, identifiers, operators, and parentheses. For numbers, 
   if the number is a multiple of 10, it is used as is; otherwise, the number is reversed.
   This lexical analyzer is then passed as input to the syntax analyzer (Parser) to proceed with the next stages of compilation. 
 




 
 `parser` file is an input file for the  `Bison` tool, which is used to generate a **Parser** (syntax analyzer).
 
 The parser is the second stage in the compilation process,
 and its job is to analyze the syntactic structure of the input text based on grammar rules.
 
 This file uses the tokens generated by the lexical analyzer (Lexer) to build a tree-like structure 
 of expressions and generates intermediate code (such as three-address code).

Explanation of the Different Sections of  Parser File:



#### **Section 1: Definitions and Settings**
```c
%{
#include <stdio.h>
#include <stdlib.h>

int temp_count = 0;

// Function to generate a new temporary variable
char* new_temp() {
    char* temp = malloc(10);
    sprintf(temp, "t%d", temp_count++);
    return temp;
}

// Forward declaration
int yylex();

void yyerror(const char *s);

int reverse(int num);

extern char *yytext;
%}
```
- This section contains C code that is included at the beginning of the syntax analyzer file.
  - `temp_count`: A counter for generating temporary variable names (e.g., `t0`, `t1`, etc.).
  - `new_temp()`: A function to generate temporary variable names.
  - `yylex()`: A function called by the lexical analyzer (Lexer) to read tokens.
  - `yyerror()`: A function to handle syntax errors.
  - `reverse()`: A function to reverse numbers (if needed).
  - `yytext`: A variable that holds the text of the current token.

---

#### **Section 2: Token Definitions and Precedence**
```bison
%token ID NUMBER
%right '+' '-'
%left '*' '/'
```
- This section defines tokens and operator precedence.
  - `ID`: Token for identifiers (variables).
  - `NUMBER`: Token for numbers.
  - `%right '+' '-'`: Addition and subtraction operators are right-associative.
  - `%left '*' '/'`: Multiplication and division operators are left-associative.

---

#### **Section 3: Union and Type Definitions**
```bison
%union {
    struct expr_data {
        char* code;   // Temporary variable or value
        int value; // Computed value (if applicable)
    } expr_data;
    char* id; 
}

%type <expr_data> expr term factor
%type <expr_data> stmt
%type <expr_data> NUMBER
%type <id> ID
```
- `%union`: A structure to hold different types of values that can be assigned to tokens or non-terminals.
  - `expr_data`: Contains two fields:
    - `code`: A string that holds intermediate code (e.g., temporary variable names).
    - `value`: The computed value of the expression.
  - `id`: A string that holds the identifier name.
- `%type`: Specifies the data type assigned to each non-terminal. For example, `expr`, `term`, and `factor` are of type `expr_data`.

---

#### **Section 4: Grammar Rules**
```bison
%%
stmt:
    ID '=' expr ';' {
        char* temp = new_temp();
        printf("Three-Address Code: %s = %s\n", $1, $3.code);
        printf("Result: %d\n", $3.value);
        free($3.code);
        YYACCEPT;
    }
    ;
```
- This section contains the grammar rules. Each rule consists of a pattern and an action.
  - `stmt`: An assignment statement (e.g., `x = 3 + 4;`).
    - `ID '=' expr ';'`: An identifier, an equals sign, an expression, and a semicolon.
    - In the code block:
      - A temporary variable (`temp`) is created.
      - The three-address code is printed (e.g., `t0 = 3 + 4`).
      - The computed result is printed.
      - Memory for `code` is freed.
      - `YYACCEPT`: The parsing is successful, and the program ends.

---

#### **Section 5: Rules for `expr`, `term`, and `factor`**
```bison
expr:
    expr '*' term {
        char* temp = new_temp();
        printf("Three-Address Code: %s = %s * %s\n", temp, $1.code, $3.code);
        int rev = reverse($1.value * $3.value);
        $$ = (struct expr_data) {temp, rev};
        free($1.code);
        free($3.code);
    }
    | expr '/' term {
        if ($3.value == 0) {
            yyerror("Division by zero");
            $$ = (struct expr_data) {strdup("error"), 0.0};
        } else {
            char* temp = new_temp();
            printf("Three-Address Code: %s = %s / %s\n", temp, $1.code, $3.code);
            int rev = reverse($1.value / $3.value);
            $$ = (struct expr_data) {temp, rev};
        }
        free($1.code);
        free($3.code);
    }
    | term {
        $$ = $1;
    }
    ;
```
- `expr`: Expressions involving multiplication, division, or a single `term`.
  - For multiplication and division:
    - A temporary variable is created.
    - The three-address code is printed.
    - The expression value is computed and reversed (if needed).
    - Memory for `code` is freed.
  - If the expression is just a `term`, its value is returned.

---

#### **Section 6: Rules for `term` and `factor`**
```bison
term:
    factor '+' term {
        char* temp = new_temp();
        printf("Three-Address Code: %s = %s + %s\n", temp, $1.code, $3.code);
        int rev = reverse($1.value + $3.value);
        $$ = (struct expr_data) {temp, rev};
        free($1.code);
        free($3.code);
    }
    | factor '-' term {
        char* temp = new_temp();
        printf("Three-Address Code: %s = %s - %s\n", temp, $1.code, $3.code);
        int rev = reverse($1.value - $3.value);
        $$ = (struct expr_data) {temp, rev};
        free($1.code);
        free($3.code);
    }
    | factor {
        $$ = $1;
    }
    ;

factor:
    '(' expr ')' {
        $$ = $2;
    }
    | NUMBER {
        $$ = (struct expr_data) {strdup($1.code), $1.value};
    }
    | '-' factor {
        $2.value = -$2.value;
        $$ = $2;
    }
    | '+' factor {
        $$ = $2;
    }
    ;
```
- `term`: Expressions involving addition, subtraction, or a single `factor`.
- `factor`: Expressions involving parentheses, numbers, or unary operators (`+` or `-`).

---

#### **Section 7: Helper Functions**
```c
int reverse(int num) {
    if (num % 10 == 0) {
        return num;
    } else {
        int reversed = 0, original = num;
        while (original != 0) {
            reversed = reversed * 10 + original % 10;
            original /= 10;
        }
        return reversed;
    }
}

int main() {
    printf("Enter an assignment expression (e.g., x = 3 * 4 + 2;):\n");
    yyparse();
    return 0;
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}
```
- `reverse()`: A function to reverse numbers (if needed).
- `main()`: The entry point of the program, which prompts the user for an expression and calls the parser (`yyparse`).
- `yyerror()`: A function to print syntax errors.

---

### **Summary:**
`parser` file creates a syntax analyzer that parses arithmetic expressions and generates three-address code.
The parser uses grammar rules to break down expressions into smaller components
(like `expr`, `term`, and `factor`) and computes their values.
For numbers that are not multiples of 10, it reverses their values. 
Finally, it prints the three-address code and the computed result.
